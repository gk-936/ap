#!/usr/bin/env python3
"""
Lightweight Python proxy server that bridges React frontend with C++ backend.
The C++ scanner acts as the actual backend, Python just facilitates communication.
"""

from flask import Flask, request, jsonify
from flask_cors import CORS
import subprocess
import json
import os
import sqlite3

app = Flask(__name__)
CORS(app)

@app.route('/api/scan', methods=['POST'])
def scan_url():
    """Proxy scan requests to C++ backend"""
    data = request.get_json()
    url = data.get('url')
    
    if not url:
        return jsonify({'error': 'URL is required'}), 400
    
    try:
        # Call C++ scanner as backend
        result = subprocess.run(
            ['./backend/vulnerability_scanner', '-u', url, '-o', 'json'], 
            capture_output=True, text=True, timeout=300, cwd=os.getcwd()
        )
        
        if result.returncode != 0:
            return jsonify({'error': 'Scanner failed', 'details': result.stderr}), 500
        
        # Return JSON report generated by C++ backend
        if os.path.exists('reports/report.json'):
            with open('reports/report.json', 'r') as f:
                return jsonify(json.load(f))
        else:
            return jsonify({'scan_results': [], 'total_vulnerabilities': 0})
            
    except subprocess.TimeoutExpired:
        return jsonify({'error': 'Scan timeout'}), 408
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/history', methods=['GET'])
def get_scan_history():
    """Get scan history from C++ backend database"""
    try:
        # Access database created by C++ backend
        conn = sqlite3.connect('backend/vulnerabilities.db')
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT s.id, s.url, s.scan_time, COUNT(v.id) as vuln_count 
            FROM scans s LEFT JOIN vulnerabilities v ON s.id = v.scan_id 
            GROUP BY s.id ORDER BY s.scan_time DESC LIMIT 10
        """)
        
        history = []
        for row in cursor.fetchall():
            history.append({
                'id': row[0],
                'url': row[1],
                'scan_time': row[2],
                'vuln_count': row[3]
            })
        
        conn.close()
        return jsonify({'history': history})
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/vulnerabilities/<int:scan_id>', methods=['GET'])
def get_vulnerabilities(scan_id):
    """Get vulnerabilities for specific scan from C++ backend database"""
    try:
        # Access database created by C++ backend
        conn = sqlite3.connect('backend/vulnerabilities.db')
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT type, url, description, severity, timestamp 
            FROM vulnerabilities WHERE scan_id = ?
        """, (scan_id,))
        
        vulnerabilities = []
        for row in cursor.fetchall():
            vulnerabilities.append({
                'type': row[0],
                'url': row[1],
                'description': row[2],
                'severity': row[3],
                'timestamp': row[4]
            })
        
        conn.close()
        return jsonify({'vulnerabilities': vulnerabilities})
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/database', methods=['GET'])
def get_database_overview():
    """Get database overview with all scans and vulnerabilities"""
    try:
        conn = sqlite3.connect('backend/vulnerabilities.db')
        cursor = conn.cursor()
        
        # Get all scans with vulnerability counts
        cursor.execute("""
            SELECT s.id, s.url, s.scan_time, COUNT(v.id) as vuln_count,
                   COUNT(CASE WHEN v.severity = 'High' THEN 1 END) as high_count,
                   COUNT(CASE WHEN v.severity = 'Medium' THEN 1 END) as medium_count
            FROM scans s LEFT JOIN vulnerabilities v ON s.id = v.scan_id 
            GROUP BY s.id ORDER BY s.scan_time DESC
        """)
        
        scans = []
        for row in cursor.fetchall():
            scans.append({
                'id': row[0],
                'url': row[1],
                'scan_time': row[2],
                'total_vulns': row[3],
                'high_vulns': row[4],
                'medium_vulns': row[5]
            })
        
        # Get total statistics
        cursor.execute("SELECT COUNT(*) FROM scans")
        total_scans = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM vulnerabilities")
        total_vulns = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM vulnerabilities WHERE severity = 'High'")
        total_high = cursor.fetchone()[0]
        
        conn.close()
        
        return jsonify({
            'scans': scans,
            'stats': {
                'total_scans': total_scans,
                'total_vulnerabilities': total_vulns,
                'high_severity': total_high
            }
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    print("Starting Python proxy server...")
    print("C++ backend: ./backend/vulnerability_scanner")
    print("React frontend: http://localhost:3000")
    print("API endpoints: http://localhost:5000/api/")
    app.run(debug=True, port=5000)