#!/usr/bin/env python3
"""
Lightweight Python proxy server that bridges React frontend with C++ backend.
The C++ scanner acts as the actual backend, Python just facilitates communication.
"""

from flask import Flask, request, jsonify
from flask_cors import CORS
from functools import wraps
import subprocess
import json
import os
import sqlite3
import traceback
import time

app = Flask(__name__)
CORS(app)

def handle_errors(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except sqlite3.Error as e:
            app.logger.error(f"Database error: {str(e)}\n{traceback.format_exc()}")
            return jsonify({'error': 'Database error occurred', 'details': str(e)}), 500
        except subprocess.TimeoutExpired:
            app.logger.error("Scanner process timeout")
            return jsonify({'error': 'Scan timeout'}), 408
        except Exception as e:
            app.logger.error(f"Unexpected error: {str(e)}\n{traceback.format_exc()}")
            return jsonify({'error': 'Internal server error', 'details': str(e)}), 500
    return wrapper

@app.route('/api/status', methods=['GET'])
@handle_errors
def get_status():
    """Check API and scanner status"""
    # Check database connection
    try:
        conn = sqlite3.connect('backend/vulnerabilities.db')
        conn.close()
    except sqlite3.Error:
        return jsonify({'status': 'error', 'message': 'Database connection failed'}), 500
        
    # Check scanner executable
    if not os.path.exists('./backend/vulnerability_scanner'):
        return jsonify({'status': 'error', 'message': 'Scanner executable not found'}), 500
    
    return jsonify({'status': 'ok'})

@app.route('/api/scan', methods=['POST'])
@handle_errors
def scan_url():
    """Proxy scan requests to C++ backend"""
    data = request.get_json()
    url = data.get('url')
    
    if not url:
        return jsonify({'error': 'URL is required'}), 400
    
    try:
        # Call C++ scanner as backend
        result = subprocess.run(
            ['./backend/vulnerability_scanner', '-u', url, '-o', 'json'], 
            capture_output=True, text=True, timeout=300, cwd=os.getcwd()
        )
        
        if result.returncode != 0:
            return jsonify({'error': 'Scanner failed', 'details': result.stderr}), 500
        
        # Return JSON report generated by C++ backend
        if os.path.exists('reports/report.json'):
            with open('reports/report.json', 'r') as f:
                return jsonify(json.load(f))
        else:
            return jsonify({'scan_results': [], 'total_vulnerabilities': 0})
            
    except subprocess.TimeoutExpired:
        return jsonify({'error': 'Scan timeout'}), 408
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/history', methods=['GET'])
def get_scan_history():
    """Get scan history from C++ backend database"""
    try:
        # Access database created by C++ backend
        conn = sqlite3.connect('backend/vulnerabilities.db')
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT s.id, s.url, s.scan_time, COUNT(v.id) as vuln_count 
            FROM scans s LEFT JOIN vulnerabilities v ON s.id = v.scan_id 
            GROUP BY s.id ORDER BY s.scan_time DESC LIMIT 10
        """)
        
        history = []
        for row in cursor.fetchall():
            history.append({
                'id': row[0],
                'url': row[1],
                'scan_time': row[2],
                'vuln_count': row[3]
            })
        
        conn.close()
        return jsonify({'history': history})
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/vulnerabilities/<int:scan_id>', methods=['GET'])
def get_vulnerabilities(scan_id):
    """Get vulnerabilities for specific scan from C++ backend database"""
    try:
        # Access database created by C++ backend
        conn = sqlite3.connect('backend/vulnerabilities.db')
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT type, url, description, severity, timestamp 
            FROM vulnerabilities WHERE scan_id = ?
        """, (scan_id,))
        
        vulnerabilities = []
        for row in cursor.fetchall():
            vulnerabilities.append({
                'type': row[0],
                'url': row[1],
                'description': row[2],
                'severity': row[3],
                'timestamp': row[4]
            })
        
        conn.close()
        return jsonify({'vulnerabilities': vulnerabilities})
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/database', methods=['GET'])
def get_database_overview():
    """Get database overview with all scans and vulnerabilities"""
    try:
        conn = sqlite3.connect('backend/vulnerabilities.db')
        cursor = conn.cursor()
        
        # Get all scans with vulnerability counts
        cursor.execute("""
            SELECT s.id, s.url, s.scan_time, COUNT(v.id) as vuln_count,
                   COUNT(CASE WHEN v.severity = 'High' THEN 1 END) as high_count,
                   COUNT(CASE WHEN v.severity = 'Medium' THEN 1 END) as medium_count
            FROM scans s LEFT JOIN vulnerabilities v ON s.id = v.scan_id 
            GROUP BY s.id ORDER BY s.scan_time DESC
        """)
        
        scans = []
        for row in cursor.fetchall():
            scans.append({
                'id': row[0],
                'url': row[1],
                'scan_time': row[2],
                'total_vulns': row[3],
                'high_vulns': row[4],
                'medium_vulns': row[5]
            })
        
        # Get total statistics
        cursor.execute("SELECT COUNT(*) FROM scans")
        total_scans = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM vulnerabilities")
        total_vulns = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM vulnerabilities WHERE severity = 'High'")
        total_high = cursor.fetchone()[0]
        
        conn.close()
        
        return jsonify({
            'scans': scans,
            'stats': {
                'total_scans': total_scans,
                'total_vulnerabilities': total_vulns,
                'high_severity': total_high
            }
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/trends', methods=['GET'])
def get_vulnerability_trends():
    """Get vulnerability trends over time from database"""
    try:
        conn = sqlite3.connect('backend/vulnerabilities.db')
        cursor = conn.cursor()
        
        # Get vulnerability counts by severity for each scan
        cursor.execute("""
            SELECT s.scan_time,
                   COUNT(CASE WHEN v.severity = 'High' THEN 1 END) as high,
                   COUNT(CASE WHEN v.severity = 'Medium' THEN 1 END) as medium,
                   COUNT(CASE WHEN v.severity = 'Low' THEN 1 END) as low
            FROM scans s LEFT JOIN vulnerabilities v ON s.id = v.scan_id 
            GROUP BY s.id, s.scan_time 
            ORDER BY s.scan_time ASC
            LIMIT 20
        """)
        
        trends = []
        for row in cursor.fetchall():
            trends.append({
                'scan_time': row[0],
                'high': row[1],
                'medium': row[2],
                'low': row[3]
            })
        
        conn.close()
        return jsonify({'trends': trends})
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/progress', methods=['GET'])
def get_scan_progress():
    """Get real-time scan progress"""
    try:
        if os.path.exists('backend/scan_progress.json'):
            with open('backend/scan_progress.json', 'r') as f:
                return jsonify(json.load(f))
        else:
            return jsonify({'progress': 0, 'scanner': 'No scan running', 'total': 6})
    except Exception as e:
        return jsonify({'progress': 0, 'scanner': 'Error reading progress', 'total': 6})

if __name__ == '__main__':
    print("Starting Python proxy server...")
    print("C++ backend: ./backend/vulnerability_scanner")
    print("React frontend: http://localhost:3000")
    print("API endpoints: http://localhost:5000/api/")
    app.run(debug=True, port=5000)