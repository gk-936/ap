#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <curl/curl.h>
#include <ctime>

using namespace std;

// Abstract base class for Vulnerability (Abstraction)
class BaseVulnerability {
protected:
    string type;
    string url;
    string description;
    string severity;
    string timestamp;
    
public:
    BaseVulnerability(string t, string u, string d, string s) {
        type = t;
        url = u;
        description = d;
        severity = s;
        
        time_t now = time(0);
        timestamp = ctime(&now);
    }
    
    // Pure virtual function (Abstraction)
    virtual string getDetails() = 0;
    
    // Virtual destructor
    virtual ~BaseVulnerability() {}
    
    // Getters (Encapsulation)
    string getType() const { return type; }
    string getURL() const { return url; }
    string getDescription() const { return description; }
    string getSeverity() const { return severity; }
    string getTimestamp() const { return timestamp; }
};

// Concrete Vulnerability class (Inheritance)
class Vulnerability : public BaseVulnerability {
public:
    Vulnerability(string t, string u, string d, string s) 
        : BaseVulnerability(t, u, d, s) {}
    
    // Override virtual function (Polymorphism)
    string getDetails() override {
        return "[" + severity + "] " + type + " at " + url;
    }
};

// Specialized vulnerability classes (Inheritance)
class HighSeverityVulnerability : public Vulnerability {
public:
    HighSeverityVulnerability(string t, string u, string d) 
        : Vulnerability(t, u, d, "High") {}
    
    // Method overriding (Polymorphism)
    string getDetails() override {
        return "CRITICAL: " + type + " at " + url + " - IMMEDIATE ACTION REQUIRED";
    }
};

class MediumSeverityVulnerability : public Vulnerability {
public:
    MediumSeverityVulnerability(string t, string u, string d) 
        : Vulnerability(t, u, d, "Medium") {}
    
    // Method overriding (Polymorphism)
    string getDetails() override {
        return "WARNING: " + type + " at " + url + " - Review recommended";
    }
};

// Abstract HTTP Client interface (Abstraction)
class IHttpClient {
public:
    virtual ~IHttpClient() {}
    virtual string makeRequest(string url) = 0;
    virtual int getResponseCode(string url) = 0;
};

// Concrete HTTP Client implementation (Inheritance)
class CurlHttpClient : public IHttpClient {
private:
    static size_t WriteCallback(void* contents, size_t size, size_t nmemb, string* data) {
        data->append((char*)contents, size * nmemb);
        return size * nmemb;
    }
    
public:
    string makeRequest(string url) override {
        string response_data;
        CURL* curl = curl_easy_init();
        
        if (curl) {
            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_data);
            curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
            
            curl_easy_perform(curl);
            curl_easy_cleanup(curl);
        }
        
        return response_data;
    }
    
    int getResponseCode(string url) override {
        CURL* curl = curl_easy_init();
        long response_code = 0;
        
        if (curl) {
            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
            curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
            curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
            
            CURLcode res = curl_easy_perform(curl);
            if (res == CURLE_OK) {
                curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);
            }
            
            curl_easy_cleanup(curl);
        }
        
        return response_code;
    }
};

// Abstract Scanner base class (Abstraction)
class BaseScanner {
protected:
    IHttpClient* client;
    
public:
    BaseScanner(IHttpClient* http_client) : client(http_client) {}
    virtual ~BaseScanner() {}
    
    // Pure virtual methods (Abstraction)
    virtual vector<BaseVulnerability*> scan(string url) = 0;
    virtual string getScannerType() = 0;
};

// Directory Traversal Scanner (Inheritance)
class DirectoryTraversalScanner : public BaseScanner {
private:
    vector<string> patterns;
    
public:
    DirectoryTraversalScanner(IHttpClient* http_client) : BaseScanner(http_client) {
        patterns = {"../", "..\\", "%2e%2e%2f", "....//"};
    }
    
    vector<BaseVulnerability*> scan(string base_url) override {
        vector<BaseVulnerability*> vulns;
        
        for (size_t i = 0; i < patterns.size(); i++) {
            string test_url = base_url + "?file=" + patterns[i] + "etc/passwd";
            
            if (client->getResponseCode(test_url) == 200) {
                string content = client->makeRequest(test_url);
                if (content.find("root:") != string::npos) {
                    vulns.push_back(new HighSeverityVulnerability("Directory Traversal", test_url,
                        "Found directory traversal with pattern: " + patterns[i]));
                }
            }
        }
        
        return vulns;
    }
    
    string getScannerType() override {
        return "Directory Traversal Scanner";
    }
};

// Sensitive File Scanner (Inheritance)
class SensitiveFileScanner : public BaseScanner {
private:
    vector<string> files;
    
public:
    SensitiveFileScanner(IHttpClient* http_client) : BaseScanner(http_client) {
        files = {"/etc/passwd", "/.env", "/config.php", "/wp-config.php", 
                "/backup.sql", "/admin/login.php", "/phpinfo.php", "/test.php",
                "/swagger.json", "/logs/error.log", "/package.json", "/.git/config",
                "/database.yml", "/robots.txt"};
    }
    
    vector<BaseVulnerability*> scan(string base_url) override {
        vector<BaseVulnerability*> vulns;
        
        for (size_t i = 0; i < files.size(); i++) {
            string test_url = base_url + files[i];
            
            if (client->getResponseCode(test_url) == 200) {
                string content = client->makeRequest(test_url);
                if (content.length() > 0) {
                    vulns.push_back(new HighSeverityVulnerability("Sensitive File Exposure", test_url,
                        "Sensitive file found: " + files[i]));
                }
            }
        }
        
        return vulns;
    }
    
    string getScannerType() override {
        return "Sensitive File Scanner";
    }
};

// Credential Scanner (Inheritance)
class CredentialScanner : public BaseScanner {
private:
    vector<string> keywords;
    
public:
    CredentialScanner(IHttpClient* http_client) : BaseScanner(http_client) {
        keywords = {"password", "api_key", "secret", "token", "@", "mysql://", "redis://",
                   "sk_live", "sk_test", "jwt", "auth_key", "session", "admin"};
    }
    
    vector<BaseVulnerability*> scan(string url) override {
        vector<BaseVulnerability*> vulns;
        
        if (client->getResponseCode(url) == 200) {
            string content = client->makeRequest(url);
            
            for (size_t i = 0; i < keywords.size(); i++) {
                if (content.find(keywords[i]) != string::npos) {
                    vulns.push_back(new MediumSeverityVulnerability("Credential Detection", url,
                        "Found potential credential: " + keywords[i]));
                }
            }
        }
        
        return vulns;
    }
    
    string getScannerType() override {
        return "Credential Scanner";
    }
};

// Abstract Report Generator (Abstraction)
class IReportGenerator {
public:
    virtual ~IReportGenerator() {}
    virtual void generateReport(vector<BaseVulnerability*> vulns) = 0;
};

// Console Report Generator (Inheritance)
class ConsoleReportGenerator : public IReportGenerator {
public:
    void generateReport(vector<BaseVulnerability*> vulns) override {
        cout << "\n=== VULNERABILITY SCAN REPORT ===\n";
        cout << "Total vulnerabilities found: " << vulns.size() << "\n\n";
        
        int high_count = 0, medium_count = 0;
        
        for (size_t i = 0; i < vulns.size(); i++) {
            if (vulns[i]->getSeverity() == "High") high_count++;
            else if (vulns[i]->getSeverity() == "Medium") medium_count++;
        }
        
        cout << "Severity breakdown:\n";
        cout << "  High: " << high_count << "\n";
        cout << "  Medium: " << medium_count << "\n\n";
        
        for (size_t i = 0; i < vulns.size(); i++) {
            cout << vulns[i]->getDetails() << "\n";
            cout << "  Description: " << vulns[i]->getDescription() << "\n";
            cout << "  Time: " << vulns[i]->getTimestamp() << "\n";
        }
    }
};

// HTML Report Generator (Inheritance)
class HTMLReportGenerator : public IReportGenerator {
private:
    string filename;
    
public:
    HTMLReportGenerator(string file) : filename(file) {}
    
    void generateReport(vector<BaseVulnerability*> vulns) override {
        ofstream file(filename);
        
        file << "<html><head><title>Vulnerability Report</title></head><body>\n";
        file << "<h1>Vulnerability Scan Report</h1>\n";
        file << "<p>Total vulnerabilities: " << vulns.size() << "</p>\n";
        file << "<table border='1'>\n";
        file << "<tr><th>Type</th><th>URL</th><th>Description</th><th>Severity</th></tr>\n";
        
        for (size_t i = 0; i < vulns.size(); i++) {
            file << "<tr>";
            file << "<td>" << vulns[i]->getType() << "</td>";
            file << "<td>" << vulns[i]->getURL() << "</td>";
            file << "<td>" << vulns[i]->getDescription() << "</td>";
            file << "<td>" << vulns[i]->getSeverity() << "</td>";
            file << "</tr>\n";
        }
        
        file << "</table></body></html>";
        file.close();
    }
};

// Main Scanner Engine (Composition)
class VulnerabilityScannerEngine {
private:
    vector<BaseScanner*> scanners;
    vector<IReportGenerator*> reporters;
    
public:
    VulnerabilityScannerEngine() {
        IHttpClient* client = new CurlHttpClient();
        
        // Add different scanners (Polymorphism)
        scanners.push_back(new DirectoryTraversalScanner(client));
        scanners.push_back(new SensitiveFileScanner(client));
        scanners.push_back(new CredentialScanner(client));
        
        // Add different reporters (Polymorphism)
        reporters.push_back(new ConsoleReportGenerator());
        reporters.push_back(new HTMLReportGenerator("report.html"));
    }
    
    ~VulnerabilityScannerEngine() {
        for (size_t i = 0; i < scanners.size(); i++) {
            delete scanners[i];
        }
        for (size_t i = 0; i < reporters.size(); i++) {
            delete reporters[i];
        }
    }
    
    vector<BaseVulnerability*> scanURL(string url) {
        vector<BaseVulnerability*> all_vulns;
        
        // Use polymorphism to call different scanner types
        for (size_t i = 0; i < scanners.size(); i++) {
            cout << "Running " << scanners[i]->getScannerType() << "...\n";
            vector<BaseVulnerability*> vulns = scanners[i]->scan(url);
            
            for (size_t j = 0; j < vulns.size(); j++) {
                all_vulns.push_back(vulns[j]);
            }
        }
        
        return all_vulns;
    }
    
    void generateReports(vector<BaseVulnerability*> vulns) {
        // Use polymorphism to generate different report types
        reporters[0]->generateReport(vulns); // Console report
        
        cout << "\nGenerate HTML report? (y/n): ";
        char choice;
        cin >> choice;
        
        if (choice == 'y' || choice == 'Y') {
            reporters[1]->generateReport(vulns); // HTML report
            cout << "HTML report saved as report.html\n";
        }
    }
};

// Main Application
class VulnerabilityScanner {
private:
    VulnerabilityScannerEngine engine;
    
public:
    void run() {
        curl_global_init(CURL_GLOBAL_DEFAULT);
        
        cout << "=== Web Vulnerability Scanner ===\n";
        cout << "Enter URL to scan: ";
        
        string url;
        cin >> url;
        
        cout << "\nScanning " << url << "...\n";
        vector<BaseVulnerability*> results = engine.scanURL(url);
        
        engine.generateReports(results);
        
        // Cleanup
        for (size_t i = 0; i < results.size(); i++) {
            delete results[i];
        }
        
        curl_global_cleanup();
    }
};

int main() {
    VulnerabilityScanner app;
    app.run();
    return 0;
}