#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <curl/curl.h>
#include <ctime>
#include <sqlite3.h>
#include <thread>
#include <mutex>
#include <future>
#include <memory>
#include <regex>
#include <sstream>
#include <iomanip>
#include <atomic>
#include <chrono>
#include <map>
#include <algorithm>

using namespace std;

// Logger Class
class Logger {
private:
    ofstream logfile;
    mutex log_mutex;
    
public:
    Logger() : logfile("logs/scanner.log", ios::app) {}
    
    void log(const string& level, const string& message) {
        lock_guard<mutex> lock(log_mutex);
        auto now = chrono::system_clock::now();
        auto time_t = chrono::system_clock::to_time_t(now);
        logfile << "[" << level << "] " << put_time(localtime(&time_t), "%Y-%m-%d %H:%M:%S") 
                << " " << message << endl;
        logfile.flush();
    }
    
    void info(const string& message) { log("INFO", message); }
    void warn(const string& message) { log("WARN", message); }
    void error(const string& message) { log("ERROR", message); }
};

// Progress Tracker Class
class ProgressTracker {
private:
    atomic<int> completed{0};
    int total;
    
public:
    void setTotal(int t) { total = t; }
    void increment() { completed++; }
    void showProgress() {
        if (total > 0) {
            cout << "\rProgress: " << completed << "/" << total 
                 << " (" << (completed * 100 / total) << "%)" << flush;
        }
    }
    void finish() { cout << "\n"; }
};

// Command Line Parser
class CommandLineParser {
public:
    struct Options {
        string url;
        bool verbose = false;
        string output_format = "console";
        bool help = false;
    };
    
    Options parse(int argc, char* argv[]) {
        Options opts;
        for (int i = 1; i < argc; i++) {
            string arg = argv[i];
            if (arg == "-u" && i + 1 < argc) opts.url = argv[++i];
            else if (arg == "-v" || arg == "--verbose") opts.verbose = true;
            else if (arg == "-o" && i + 1 < argc) opts.output_format = argv[++i];
            else if (arg == "-h" || arg == "--help") opts.help = true;
        }
        return opts;
    }
    
    void showHelp() {
        cout << "Usage: ./vulnerability_scanner [OPTIONS]\n";
        cout << "Options:\n";
        cout << "  -u <url>     Target URL to scan\n";
        cout << "  -v, --verbose Enable verbose logging\n";
        cout << "  -o <format>  Output format (console, html, json)\n";
        cout << "  -h, --help   Show this help message\n";
    }
};

// URL Validator Class
class URLValidator {
private:
    vector<string> allowed_schemes = {"http", "https"};
    vector<string> blocked_hosts = {"localhost", "127.0.0.1", "0.0.0.0", "169.254.169.254"};
    
public:
    bool isValidURL(const string& url) {
        regex url_pattern(R"(^(https?):\/\/([^\/\s]+)(\/.*)?$)");
        smatch matches;
        
        if (!regex_match(url, matches, url_pattern)) {
            return false;
        }
        
        string scheme = matches[1].str();
        string host = matches[2].str();
        
        if (find(allowed_schemes.begin(), allowed_schemes.end(), scheme) == allowed_schemes.end()) {
            return false;
        }
        
        for (const auto& blocked : blocked_hosts) {
            if (host.find(blocked) != string::npos) {
                return false;
            }
        }
        
        return true;
    }
};

// Configuration Loader
class ConfigLoader {
public:
    static vector<string> loadFromFile(const string& filename) {
        vector<string> items;
        ifstream file(filename);
        string line;
        
        if (!file.is_open()) {
            cerr << "Warning: Could not open " << filename << endl;
            return items;
        }
        
        while (getline(file, line)) {
            if (!line.empty() && line[0] != '#') {
                items.push_back(line);
            }
        }
        
        file.close();
        return items;
    }
};

// HTTP Response Structure
struct HttpResponse {
    int status_code;
    string content;
    bool success;
};

// Abstract base class for Vulnerability
class BaseVulnerability {
protected:
    string type;
    string url;
    string description;
    string severity;
    string timestamp;
    
public:
    BaseVulnerability(const string& t, const string& u, const string& d, const string& s) 
        : type(t), url(u), description(d), severity(s) {
        time_t now = time(0);
        char* time_str = ctime(&now);
        timestamp = string(time_str);
        if (!timestamp.empty() && timestamp.back() == '\n') {
            timestamp.pop_back();
        }
    }
    
    virtual ~BaseVulnerability() {}
    virtual string getDetails() = 0;
    
    const string& getType() const { return type; }
    const string& getURL() const { return url; }
    const string& getDescription() const { return description; }
    const string& getSeverity() const { return severity; }
    const string& getTimestamp() const { return timestamp; }
};

class Vulnerability : public BaseVulnerability {
public:
    Vulnerability(const string& t, const string& u, const string& d, const string& s) 
        : BaseVulnerability(t, u, d, s) {}
    
    string getDetails() override {
        stringstream ss;
        ss << "[" << severity << "] " << type << " at " << url;
        return ss.str();
    }
};

class CriticalSeverityVulnerability : public Vulnerability {
public:
    CriticalSeverityVulnerability(const string& t, const string& u, const string& d) 
        : Vulnerability(t, u, d, "High") {}
    
    string getDetails() override {
        stringstream ss;
        ss << "CRITICAL: " << type << " at " << url << " - IMMEDIATE ACTION REQUIRED";
        return ss.str();
    }
};

class MediumSeverityVulnerability : public Vulnerability {
public:
    MediumSeverityVulnerability(const string& t, const string& u, const string& d) 
        : Vulnerability(t, u, d, "Medium") {}
    
    string getDetails() override {
        stringstream ss;
        ss << "WARNING: " << type << " at " << url << " - Review recommended";
        return ss.str();
    }
};

// Abstract HTTP Client interface
class IHttpClient {
public:
    virtual ~IHttpClient() {}
    virtual HttpResponse makeRequest(const string& url) = 0;
};

// Thread-safe HTTP Client implementation
class CurlHttpClient : public IHttpClient {
private:
    static size_t WriteCallback(void* contents, size_t size, size_t nmemb, string* data) {
        data->append((char*)contents, size * nmemb);
        return size * nmemb;
    }
    
public:
    HttpResponse makeRequest(const string& url) override {
        HttpResponse response = {0, "", false};
        CURL* curl = curl_easy_init();
        
        if (!curl) {
            return response;
        }
        
        try {
            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response.content);
            curl_easy_setopt(curl, CURLOPT_TIMEOUT, 5L);
            curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 3L);
            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
            curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 3L);
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
            curl_easy_setopt(curl, CURLOPT_USERAGENT, "VulnScanner/1.0");
            
            CURLcode res = curl_easy_perform(curl);
            
            if (res == CURLE_OK) {
                long response_code;
                curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);
                response.status_code = static_cast<int>(response_code);
                response.success = true;
            }
            
            curl_easy_cleanup(curl);
        } catch (...) {
            curl_easy_cleanup(curl);
        }
        
        return response;
    }
};

// Abstract Scanner base class with template method
class BaseScanner {
protected:
    shared_ptr<IHttpClient> client;
    vector<string> loadedPatterns;
    
public:
    BaseScanner(shared_ptr<IHttpClient> http_client) : client(http_client) {}
    virtual ~BaseScanner() {
        clearResources();
    }
    
    // Template method that defines scanning algorithm
    virtual vector<unique_ptr<BaseVulnerability>> scan(const string& url) {
        vector<unique_ptr<BaseVulnerability>> vulns;
        loadedPatterns = getPatterns();
        
        for (const auto& pattern : loadedPatterns) {
            try {
                if (auto vuln = checkVulnerability(url, pattern)) {
                    vulns.push_back(move(vuln));
                }
            } catch (const exception& e) {
                cerr << "Error scanning with pattern " << pattern << ": " << e.what() << endl;
            }
        }
        
        clearResources();
        return vulns;
    }
    
    virtual string getScannerType() = 0;
    
    void clearResources() {
        clearPatterns();
        clearTempFiles();
    }
    
    void clearPatterns() {
        loadedPatterns.clear();
        loadedPatterns.shrink_to_fit();
    }
    
    virtual void clearTempFiles() {
        // Override in derived classes if they create temp files
    }
    
protected:
    virtual vector<string> getPatterns() = 0;
    virtual unique_ptr<BaseVulnerability> checkVulnerability(const string& url, const string& pattern) = 0;
};

// Directory Traversal Scanner
class DirectoryTraversalScanner : public BaseScanner {
private:
    vector<string> patterns;
    
public:
    DirectoryTraversalScanner(shared_ptr<IHttpClient> http_client) : BaseScanner(http_client) {
        patterns = ConfigLoader::loadFromFile("config/patterns.txt");
        if (patterns.empty()) {
            patterns = {"../", "..\\", "%2e%2e%2f", "....//", "..%2f"};
        }
    }

    vector<string> getPatterns() override {
        return patterns;
    }
    
    unique_ptr<BaseVulnerability> checkVulnerability(const string& url, const string& pattern) override {
        string test_url = url + "?file=" + pattern + "etc/passwd";
        HttpResponse response = client->makeRequest(test_url);
        if (response.success && response.status_code == 200) {
            if (response.content.find("root:") != string::npos) {
                return make_unique<CriticalSeverityVulnerability>(
                    "Directory Traversal", test_url,
                    "Found directory traversal with pattern: " + pattern);
            }
        }
        return nullptr;
    }
    
    string getScannerType() override {
        return "Directory Traversal Scanner";
    }
};

// Sensitive File Scanner
class SensitiveFileScanner : public BaseScanner {
private:
    vector<string> files;
    
public:
    SensitiveFileScanner(shared_ptr<IHttpClient> http_client) : BaseScanner(http_client) {
        files = ConfigLoader::loadFromFile("config/sensitive_files.txt");
        if (files.empty()) {
            files = {"/etc/passwd", "/.env", "/config.php", "/wp-config.php", "/backup.sql"};
        }
    }
    
    vector<string> getPatterns() override {
        return files;
    }
    
    unique_ptr<BaseVulnerability> checkVulnerability(const string& url, const string& pattern) override {
        string test_url = url + pattern;
        HttpResponse response = client->makeRequest(test_url);
        if (response.success && response.status_code == 200 && !response.content.empty()) {
            return make_unique<CriticalSeverityVulnerability>(
                "Sensitive File Exposure", test_url,
                "Sensitive file found: " + pattern);
        }
        return nullptr;
    }
    
    string getScannerType() override {
        return "Sensitive File Scanner";
    }
};

// Credential Scanner
class CredentialScanner : public BaseScanner {
private:
    vector<string> keywords;
    
public:
    CredentialScanner(shared_ptr<IHttpClient> http_client) : BaseScanner(http_client) {
        keywords = ConfigLoader::loadFromFile("config/keywords.txt");
        if (keywords.empty()) {
            keywords = {"password", "api_key", "secret", "token", "mysql://", "sk_live"};
        }
    }
    
    vector<string> getPatterns() override {
        return keywords;
    }
    
    unique_ptr<BaseVulnerability> checkVulnerability(const string& url, const string& pattern) override {
        HttpResponse response = client->makeRequest(url);
        if (response.success && response.status_code == 200) {
            if (response.content.find(pattern) != string::npos) {
                return make_unique<MediumSeverityVulnerability>(
                    "Credential Detection", url,
                    "Found potential credential: " + pattern);
            }
        }
        return nullptr;
    }
    
    string getScannerType() override {
        return "Credential Scanner";
    }
};

// SQL Injection Scanner
class SQLInjectionScanner : public BaseScanner {
private:
    vector<string> payloads;
    
public:
    SQLInjectionScanner(shared_ptr<IHttpClient> http_client) : BaseScanner(http_client) {
        payloads = {"'", "1' OR '1'='1", "'; DROP TABLE--", "\" OR 1=1--", "' UNION SELECT NULL--"};
    }
    
    vector<string> getPatterns() override {
        return payloads;
    }
    
    unique_ptr<BaseVulnerability> checkVulnerability(const string& url, const string& pattern) override {
        string test_url = url + "?id=" + pattern;
        HttpResponse response = client->makeRequest(test_url);
        if (response.success && response.status_code == 200) {
            if (response.content.find("SQL syntax") != string::npos ||
                response.content.find("mysql_fetch") != string::npos ||
                response.content.find("ORA-") != string::npos ||
                response.content.find("sqlite") != string::npos) {
                return make_unique<CriticalSeverityVulnerability>(
                    "SQL Injection", test_url,
                    "Potential SQL injection vulnerability detected");
            }
        }
        return nullptr;
    }
    
    string getScannerType() override {
        return "SQL Injection Scanner";
    }
};

// XSS Scanner
class XSSScanner : public BaseScanner {
private:
    vector<string> payloads;
    
public:
    XSSScanner(shared_ptr<IHttpClient> http_client) : BaseScanner(http_client) {
        payloads = {"<script>alert(1)</script>", "javascript:alert(1)", "<img src=x onerror=alert(1)>", "'><script>alert(1)</script>"};
    }
    
    vector<string> getPatterns() override {
        return payloads;
    }
    
    unique_ptr<BaseVulnerability> checkVulnerability(const string& url, const string& pattern) override {
        string test_url = url + "?q=" + pattern;
        HttpResponse response = client->makeRequest(test_url);
        if (response.success && response.status_code == 200) {
            if (response.content.find("<script>") != string::npos ||
                response.content.find("javascript:") != string::npos) {
                return make_unique<CriticalSeverityVulnerability>(
                    "Cross-Site Scripting (XSS)", test_url,
                    "Potential XSS vulnerability detected");
            }
        }
        return nullptr;
    }
    
    string getScannerType() override {
        return "XSS Scanner";
    }
};

// Command Injection Scanner
class CommandInjectionScanner : public BaseScanner {
private:
    vector<string> payloads;
    
public:
    CommandInjectionScanner(shared_ptr<IHttpClient> http_client) : BaseScanner(http_client) {
        payloads = {"; ls", "| whoami", "&& id", "; cat /etc/passwd", "| ping -c 1 127.0.0.1"};
    }
    
    vector<string> getPatterns() override {
        return payloads;
    }
    
    unique_ptr<BaseVulnerability> checkVulnerability(const string& url, const string& pattern) override {
        string test_url = url + "?cmd=test" + pattern;
        HttpResponse response = client->makeRequest(test_url);
        if (response.success && response.status_code == 200) {
            if (response.content.find("uid=") != string::npos ||
                response.content.find("root:") != string::npos ||
                response.content.find("PING") != string::npos ||
                response.content.find("bin/") != string::npos) {
                return make_unique<CriticalSeverityVulnerability>(
                    "Command Injection", test_url,
                    "Potential command injection vulnerability detected");
            }
        }
        return nullptr;
    }
    
    string getScannerType() override {
        return "Command Injection Scanner";
    }
};

// Thread-safe Database Manager
class DatabaseManager {
private:
    sqlite3* db;
    static unique_ptr<DatabaseManager> instance;
    static mutex instance_mutex;
    mutex db_mutex;
    
    DatabaseManager() : db(nullptr) {
        initDatabase();
    }
    
    void initDatabase() {
        int rc = sqlite3_open("vulnerabilities.db", &db);
        if (rc != SQLITE_OK) {
            cerr << "Can't open database: " << sqlite3_errmsg(db) << endl;
            db = nullptr;
            return;
        }
        
        const char* sql = "CREATE TABLE IF NOT EXISTS scans ("
                         "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                         "url TEXT NOT NULL,"
                         "scan_time TEXT NOT NULL);"
                         
                         "CREATE TABLE IF NOT EXISTS vulnerabilities ("
                         "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                         "scan_id INTEGER,"
                         "type TEXT NOT NULL,"
                         "url TEXT NOT NULL,"
                         "description TEXT,"
                         "severity TEXT,"
                         "timestamp TEXT,"
                         "FOREIGN KEY(scan_id) REFERENCES scans(id));";
        
        char* errMsg = 0;
        rc = sqlite3_exec(db, sql, 0, 0, &errMsg);
        if (rc != SQLITE_OK) {
            cerr << "SQL error: " << errMsg << endl;
            sqlite3_free(errMsg);
        }
    }
    
public:
    static DatabaseManager* getInstance() {
        lock_guard<mutex> lock(instance_mutex);
        if (!instance) {
            instance = unique_ptr<DatabaseManager>(new DatabaseManager());
        }
        return instance.get();
    }
    
    ~DatabaseManager() {
        if (db) {
            sqlite3_close(db);
        }
    }
    
    int createScan(const string& url) {
        lock_guard<mutex> lock(db_mutex);
        
        if (!db) return -1;
        
        const char* sql = "INSERT INTO scans (url, scan_time) VALUES (?, datetime('now'));";
        sqlite3_stmt* stmt;
        
        if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) {
            cerr << "SQL prepare error: " << sqlite3_errmsg(db) << endl;
            return -1;
        }
        
        sqlite3_bind_text(stmt, 1, url.c_str(), -1, SQLITE_STATIC);
        
        int result = sqlite3_step(stmt);
        if (result != SQLITE_DONE) {
            cerr << "SQL execution error: " << sqlite3_errmsg(db) << endl;
            sqlite3_finalize(stmt);
            return -1;
        }
        
        int scan_id = sqlite3_last_insert_rowid(db);
        sqlite3_finalize(stmt);
        return scan_id;
    }
    
    bool saveVulnerability(int scan_id, BaseVulnerability* vuln) {
        lock_guard<mutex> lock(db_mutex);
        
        if (!db) return false;
        
        const char* sql = "INSERT INTO vulnerabilities (scan_id, type, url, description, severity, timestamp) "
                         "VALUES (?, ?, ?, ?, ?, ?);";
        sqlite3_stmt* stmt;
        
        if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) {
            cerr << "SQL prepare error: " << sqlite3_errmsg(db) << endl;
            return false;
        }
        
        sqlite3_bind_int(stmt, 1, scan_id);
        sqlite3_bind_text(stmt, 2, vuln->getType().c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 3, vuln->getURL().c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 4, vuln->getDescription().c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 5, vuln->getSeverity().c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 6, vuln->getTimestamp().c_str(), -1, SQLITE_STATIC);
        
        int result = sqlite3_step(stmt);
        bool success = (result == SQLITE_DONE);
        
        if (!success) {
            cerr << "SQL execution error: " << sqlite3_errmsg(db) << endl;
        }
        
        sqlite3_finalize(stmt);
        return success;
    }
    
    void showScanHistory() {
        lock_guard<mutex> lock(db_mutex);
        
        if (!db) return;
        
        const char* sql = "SELECT s.id, s.url, s.scan_time, COUNT(v.id) as vuln_count "
                         "FROM scans s LEFT JOIN vulnerabilities v ON s.id = v.scan_id "
                         "GROUP BY s.id ORDER BY s.scan_time DESC LIMIT 10;";
        sqlite3_stmt* stmt;
        
        if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) {
            cerr << "SQL prepare error: " << sqlite3_errmsg(db) << endl;
            return;
        }
        
        cout << "\n=== SCAN HISTORY ===\n";
        cout << left << setw(5) << "ID" << setw(30) << "URL" << setw(25) << "Time" << "Vulns\n";
        cout << string(65, '-') << "\n";
        
        while (sqlite3_step(stmt) == SQLITE_ROW) {
            cout << left << setw(5) << sqlite3_column_int(stmt, 0);
            cout << setw(30) << (char*)sqlite3_column_text(stmt, 1);
            cout << setw(25) << (char*)sqlite3_column_text(stmt, 2);
            cout << sqlite3_column_int(stmt, 3) << "\n";
        }
        
        sqlite3_finalize(stmt);
    }
    
    void exportScanHistory() {
        lock_guard<mutex> lock(db_mutex);
        
        if (!db) {
            cerr << "Error: Database not available\n";
            return;
        }
        
        cout << "\nExporting scan history...\n";
        
        ofstream file("reports/scan_history.json");
        if (!file.is_open()) {
            cerr << "Error: Could not create export file\n";
            return;
        }
        
        const char* scan_sql = "SELECT s.id, s.url, s.scan_time, "
                              "COUNT(v.id) as total_vulns, "
                              "SUM(CASE WHEN v.severity = 'High' THEN 1 ELSE 0 END) as high_vulns, "
                              "SUM(CASE WHEN v.severity = 'Medium' THEN 1 ELSE 0 END) as medium_vulns "
                              "FROM scans s LEFT JOIN vulnerabilities v ON s.id = v.scan_id "
                              "GROUP BY s.id ORDER BY s.scan_time DESC;";
        
        sqlite3_stmt* scan_stmt;
        if (sqlite3_prepare_v2(db, scan_sql, -1, &scan_stmt, NULL) != SQLITE_OK) {
            cerr << "SQL prepare error: " << sqlite3_errmsg(db) << endl;
            file.close();
            return;
        }
        
        auto now = chrono::system_clock::now();
        auto timestamp = chrono::duration_cast<chrono::seconds>(now.time_since_epoch()).count();
        
        file << "{\n";
        file << "  \"export_info\": {\n";
        file << "    \"export_time\": \"" << timestamp << "\",\n";
        file << "    \"format_version\": \"1.0\"\n";
        file << "  },\n";
        file << "  \"scans\": [\n";
        
        bool first_scan = true;
        while (sqlite3_step(scan_stmt) == SQLITE_ROW) {
            if (!first_scan) file << ",\n";
            first_scan = false;
            
            int scan_id = sqlite3_column_int(scan_stmt, 0);
            const char* url = (char*)sqlite3_column_text(scan_stmt, 1);
            const char* scan_time = (char*)sqlite3_column_text(scan_stmt, 2);
            int total_vulns = sqlite3_column_int(scan_stmt, 3);
            int high_vulns = sqlite3_column_int(scan_stmt, 4);
            int medium_vulns = sqlite3_column_int(scan_stmt, 5);
            
            file << "    {\n";
            file << "      \"scan_id\": " << scan_id << ",\n";
            file << "      \"url\": \"" << (url ? url : "") << "\",\n";
            file << "      \"scan_time\": \"" << (scan_time ? scan_time : "") << "\",\n";
            file << "      \"vulnerability_summary\": {\n";
            file << "        \"total\": " << total_vulns << ",\n";
            file << "        \"high\": " << high_vulns << ",\n";
            file << "        \"medium\": " << medium_vulns << "\n";
            file << "      }\n";
            file << "    }";
        }
        
        file << "\n  ]\n";
        file << "}";
        
        sqlite3_finalize(scan_stmt);
        file.close();
        
        cout << "Complete scan history exported to reports/scan_history.json\n";
    }
};

unique_ptr<DatabaseManager> DatabaseManager::instance = nullptr;
mutex DatabaseManager::instance_mutex;

// Abstract Report Generator
class IReportGenerator {
public:
    virtual ~IReportGenerator() {}
    virtual void generateReport(const vector<unique_ptr<BaseVulnerability>>& vulns) = 0;
};

// Console Report Generator
class ConsoleReportGenerator : public IReportGenerator {
public:
    void generateReport(const vector<unique_ptr<BaseVulnerability>>& vulns) override {
        cout << "\n=== VULNERABILITY SCAN REPORT ===\n";
        cout << "Total vulnerabilities found: " << vulns.size() << "\n\n";
        
        int high_count = 0, medium_count = 0;
        
        for (const auto& vuln : vulns) {
            if (vuln->getSeverity() == "High") high_count++;
            else if (vuln->getSeverity() == "Medium") medium_count++;
        }
        
        cout << "Severity breakdown:\n";
        cout << "  High: " << high_count << "\n";
        cout << "  Medium: " << medium_count << "\n\n";
        
        for (const auto& vuln : vulns) {
            cout << vuln->getDetails() << "\n";
            cout << "  Description: " << vuln->getDescription() << "\n";
            cout << "  Time: " << vuln->getTimestamp() << "\n\n";
        }
    }
};

// HTML Report Generator
class HTMLReportGenerator : public IReportGenerator {
private:
    string filename;
    
public:
    HTMLReportGenerator(const string& file) : filename("reports/" + file) {}
    
    void generateReport(const vector<unique_ptr<BaseVulnerability>>& vulns) override {
        ofstream file(filename);
        
        if (!file.is_open()) {
            cerr << "Error: Could not create HTML report file: " << filename << endl;
            return;
        }
        
        file << "<!DOCTYPE html>\n<html><head><title>Vulnerability Report</title>\n";
        file << "<style>table{border-collapse:collapse;width:100%;}th,td{border:1px solid #ddd;padding:8px;text-align:left;}th{background-color:#f2f2f2;}</style>\n";
        file << "</head><body>\n";
        file << "<h1>Vulnerability Scan Report</h1>\n";
        file << "<p>Total vulnerabilities: " << vulns.size() << "</p>\n";
        file << "<table>\n";
        file << "<tr><th>Type</th><th>URL</th><th>Description</th><th>Severity</th><th>Timestamp</th></tr>\n";
        
        for (const auto& vuln : vulns) {
            file << "<tr>";
            file << "<td>" << vuln->getType() << "</td>";
            file << "<td>" << vuln->getURL() << "</td>";
            file << "<td>" << vuln->getDescription() << "</td>";
            file << "<td>" << vuln->getSeverity() << "</td>";
            file << "<td>" << vuln->getTimestamp() << "</td>";
            file << "</tr>\n";
        }
        
        file << "</table></body></html>";
        file.close();
    }
};

// JSON Report Generator
class JSONReportGenerator : public IReportGenerator {
private:
    string filename;
    
public:
    JSONReportGenerator(const string& file) : filename("reports/" + file) {}
    
    void generateReport(const vector<unique_ptr<BaseVulnerability>>& vulns) override {
        ofstream file(filename);
        
        if (!file.is_open()) {
            cerr << "Error: Could not create JSON report file: " << filename << endl;
            return;
        }
        
        file << "{\n  \"scan_results\": [\n";
        for (size_t i = 0; i < vulns.size(); i++) {
            file << "    {\n";
            file << "      \"type\": \"" << vulns[i]->getType() << "\",\n";
            file << "      \"url\": \"" << vulns[i]->getURL() << "\",\n";
            file << "      \"description\": \"" << vulns[i]->getDescription() << "\",\n";
            file << "      \"severity\": \"" << vulns[i]->getSeverity() << "\",\n";
            file << "      \"timestamp\": \"" << vulns[i]->getTimestamp() << "\"\n";
            file << "    }" << (i < vulns.size() - 1 ? "," : "") << "\n";
        }
        file << "  ],\n";
        file << "  \"total_vulnerabilities\": " << vulns.size() << ",\n";
        file << "  \"scan_timestamp\": \"" << chrono::duration_cast<chrono::seconds>(chrono::system_clock::now().time_since_epoch()).count() << "\"\n";
        file << "}";
        file.close();
    }
};

// Sequential Scanner Engine
class VulnerabilityScannerEngine {
private:
    vector<unique_ptr<BaseScanner>> scanners;
    vector<unique_ptr<IReportGenerator>> reporters;
    DatabaseManager* db;
    shared_ptr<IHttpClient> client;
    URLValidator validator;
    int current_scan_id;

    // Helper method to clear scanner resources
    void clearScannerResources(BaseScanner* scanner) {
        if (scanner) {
            scanner->clearPatterns();
            scanner->clearTempFiles();
        }
    }

    // Helper method to perform single scanner operation
    vector<unique_ptr<BaseVulnerability>> runSingleScanner(BaseScanner* scanner, const string& url) {
        vector<unique_ptr<BaseVulnerability>> vulns;
        try {
            // Run scan
            vulns = scanner->scan(url);
            
            // Immediately store results in database
            for (const auto& vuln : vulns) {
                if (vuln) {
                    db->saveVulnerability(current_scan_id, vuln.get());
                }
            }
            
            // Clear scanner resources
            clearScannerResources(scanner);
        } catch (...) {
            clearScannerResources(scanner);
            throw;
        }
        return vulns;
    }
    
public:
    VulnerabilityScannerEngine() {
        client = make_shared<CurlHttpClient>();
        db = DatabaseManager::getInstance();
        
        scanners.push_back(make_unique<DirectoryTraversalScanner>(client));
        scanners.push_back(make_unique<SensitiveFileScanner>(client));
        scanners.push_back(make_unique<CredentialScanner>(client));
        scanners.push_back(make_unique<SQLInjectionScanner>(client));
        scanners.push_back(make_unique<XSSScanner>(client));
        scanners.push_back(make_unique<CommandInjectionScanner>(client));
        
        reporters.push_back(make_unique<ConsoleReportGenerator>());
        reporters.push_back(make_unique<HTMLReportGenerator>("report.html"));
        reporters.push_back(make_unique<JSONReportGenerator>("report.json"));
    }
    
    vector<unique_ptr<BaseVulnerability>> scanURL(const string& url) {
        Logger logger;
        ProgressTracker progress;
        
        if (!validator.isValidURL(url)) {
            logger.error("Invalid or potentially dangerous URL: " + url);
            cerr << "Error: Invalid or potentially dangerous URL: " << url << endl;
            return vector<unique_ptr<BaseVulnerability>>();
        }
        
        logger.info("Starting scan for URL: " + url);
        vector<unique_ptr<BaseVulnerability>> all_vulns;
        
        progress.setTotal(scanners.size());
        current_scan_id = db->createScan(url);
        
        // Write initial progress
        ofstream progressFile("backend/scan_progress.json");
        progressFile << "{\"progress\": 0, \"scanner\": \"Starting scan\", \"total\": " << scanners.size() << "}";
        progressFile.close();
        
        // Run scanners sequentially, but each scanner uses multi-threading internally
        for (size_t i = 0; i < scanners.size(); i++) {
            try {
                // Update progress file
                ofstream pf("backend/scan_progress.json");
                pf << "{\"progress\": " << i << ", \"scanner\": \"" << scanners[i]->getScannerType() << "\", \"total\": " << scanners.size() << "}";
                pf.close();
                
                logger.info("Running " + scanners[i]->getScannerType());
                cout << "Running " << scanners[i]->getScannerType() << "..." << flush;
                
                auto vulns = scanners[i]->scan(url);
                
                for (auto& vuln : vulns) {
                    if (current_scan_id != -1) {
                        db->saveVulnerability(current_scan_id, vuln.get());
                    }
                    all_vulns.push_back(move(vuln));
                }
                
                progress.increment();
                progress.showProgress();
                cout << " Complete\n";
                
            } catch (const exception& e) {
                logger.error("Scanner error: " + string(e.what()));
                cout << " Failed: " << e.what() << "\n";
                progress.increment();
                progress.showProgress();
            }
        }
        
        // Write completion
        ofstream completePf("backend/scan_progress.json");
        completePf << "{\"progress\": " << scanners.size() << ", \"scanner\": \"Scan complete\", \"total\": " << scanners.size() << "}";
        completePf.close();
        
        progress.finish();
        logger.info("Scan completed. Found " + to_string(all_vulns.size()) + " vulnerabilities");
        return all_vulns;
    }
    
    void generateReports(const vector<unique_ptr<BaseVulnerability>>& vulns) {
        reporters[0]->generateReport(vulns);
        
        cout << "\nGenerate additional reports? (h=HTML, j=JSON, n=No): ";
        char choice;
        
        while (!(cin >> choice) || (choice != 'h' && choice != 'H' && choice != 'j' && choice != 'J' && choice != 'n' && choice != 'N')) {
            cout << "Invalid input. Please enter 'h', 'j', or 'n': ";
            cin.clear();
            cin.ignore(10000, '\n');
        }
        
        if (choice == 'h' || choice == 'H') {
            reporters[1]->generateReport(vulns);
            cout << "HTML report saved as report.html\n";
        } else if (choice == 'j' || choice == 'J') {
            reporters[2]->generateReport(vulns);
            cout << "JSON report saved as report.json\n";
        }
    }
    
    void generateReportByFormat(const vector<unique_ptr<BaseVulnerability>>& vulns, const string& format) {
        if (format == "json") {
            reporters[2]->generateReport(vulns);
        } else if (format == "html") {
            reporters[1]->generateReport(vulns);
        } else {
            reporters[0]->generateReport(vulns);
        }
    }
};

// Main Application
class VulnerabilityScanner {
private:
    VulnerabilityScannerEngine engine;
    DatabaseManager* db;
    
public:
    VulnerabilityScanner() {
        db = DatabaseManager::getInstance();
    }
    

    
    void showMenu() {
        cout << "\n=== Web Vulnerability Scanner ===\n";
        cout << "1. Scan URL\n";
        cout << "2. View Scan History\n";
        cout << "3. Export Scan History\n";
        cout << "4. Exit\n";
        cout << "Choose option: ";
    }
    
    void runCLI() {
        curl_global_init(CURL_GLOBAL_DEFAULT);
        
        int choice;
        do {
            showMenu();
            
            while (!(cin >> choice) || choice < 1 || choice > 4) {
                cout << "Invalid option. Please enter 1, 2, 3, or 4: ";
                cin.clear();
                cin.ignore(10000, '\n');
            }
            
            switch(choice) {
                case 1: {
                    cout << "Enter URL to scan: ";
                    string url;
                    cin >> url;
                    
                    cout << "\nScanning " << url << "...\n";
                    auto results = engine.scanURL(url);
                    
                    if (!results.empty()) {
                        engine.generateReports(results);
                        // Always generate JSON for consistency
                        engine.generateReportByFormat(results, "json");
                        cout << "JSON report automatically saved as reports/report.json\n";
                    } else {
                        cout << "No vulnerabilities found or scan failed.\n";
                    }
                    break;
                }
                case 2:
                    db->showScanHistory();
                    break;
                case 3:
                    db->exportScanHistory();
                    break;
                case 4:
                    cout << "Goodbye!\n";
                    break;
            }
        } while (choice != 4);
        
        curl_global_cleanup();
    }
    
    void runCommand(const CommandLineParser::Options& opts) {
        curl_global_init(CURL_GLOBAL_DEFAULT);
        
        auto results = engine.scanURL(opts.url);
        engine.generateReportByFormat(results, opts.output_format);
        
        curl_global_cleanup();
    }
};

int main(int argc, char* argv[]) {
    try {
        CommandLineParser parser;
        auto opts = parser.parse(argc, argv);
        
        if (opts.help) {
            parser.showHelp();
            return 0;
        }
        
        VulnerabilityScanner app;
        
        if (!opts.url.empty()) {
            // Command line mode
            app.runCommand(opts);
        } else {
            // Interactive CLI mode
            app.runCLI();
        }
        
    } catch (const exception& e) {
        cerr << "Application error: " << e.what() << endl;
        return 1;
    }
    
    return 0;
}